#!/usr/bin/env bash
# Pre-commit hook pour gÃ©rer automatiquement version et statut des blueprints
# Compatible Windows (Git Bash), Linux et Mac
#
# Structure attendue en dÃ©but de fichier :
#   # Version: X.X.X
#   # ðŸ§ª to test : <commit message>   OU   # âœ… working   OU   # âœ… working : <commentaire>
#   # Appartement: ...
#
# Logique :
#   - Si le fichier est modifiÃ© (pas juste validation) â†’ bump version + statut "ðŸ§ª to test"
#   - Si seule la ligne 2 change de "ðŸ§ª to test" vers "âœ… working" â†’ pas de bump (validation)
#   - Le message de commit final est appliquÃ© par le commit-msg hook
#   - GÃ©nÃ¨re automatiquement status.md avec l'Ã©tat de tous les blueprints

BLUEPRINTS_DIR="blueprints/automation/DavidBabel"
STATUS_FILE="blueprints/status.md"

# En pre-commit, on n'a pas encore le message de commit
# On utilise un placeholder qui sera remplacÃ© par commit-msg hook
commit_msg="pending"

# RÃ©cupÃ©rer les fichiers stagÃ©s (on teste en mode texte, puis on itÃ¨re en NUL-delimited)
staged_files_text=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$staged_files_text" ]; then
    exit 0
fi

modified_files=()
validated_files=()

while IFS= read -r -d '' file; do
    # Protection Windows: enlever un Ã©ventuel \r rÃ©siduel
    file=${file//$'\r'/}

    # Exclure les blueprints dans un dossier "trash"
    if [[ "$file" == *"/trash/"* ]]; then
        continue
    fi
    # VÃ©rifier si c'est un blueprint
    if [[ $file =~ ^blueprints/automation/.+\.yaml$ ]] && [ -f "$file" ]; then

        # Lire les lignes actuelles
        line1=$(sed -n '1p' "$file" | tr -d '\r')
        line2=$(sed -n '2p' "$file" | tr -d '\r')

        # Si le hook a dÃ©jÃ  prÃ©parÃ© ce fichier pour CE commit (placeholder pending), ne pas rebump
        if echo "$line2" | grep -Eq "to test[[:space:]]*:[[:space:]]*pending"; then
            echo "âœ“ Blueprint dÃ©jÃ  prÃ©parÃ© : $file"
            continue
        fi

        # VÃ©rifier si le fichier a dÃ©jÃ  une version
        if [[ ! "$line1" =~ ^#\ Version: ]]; then
            # Nouveau fichier sans version â†’ initialiser
            current_version="0.0.0"
            new_version="1.0.0"

            # Ajouter les lignes de version et statut au dÃ©but
            temp_file="${file}.tmp"
            {
                echo "# Version: $new_version"
                echo "# ðŸ§ª to test : $commit_msg"
                cat "$file"
            } > "$temp_file"
            mv "$temp_file" "$file"

            git add "$file"
            modified_files+=("$file: NOUVEAU â†’ $new_version")
            echo "âœ“ Nouveau blueprint initialisÃ© : $file"
            continue
        fi

        # Extraire la version actuelle
        current_version=$(echo "$line1" | sed -E 's/^# Version:\s*([0-9]+\.[0-9]+\.[0-9]+)/\1/')

        # VÃ©rifier si c'est une simple validation (seul changement = ligne 2 â†’ "âœ… working")
        # On compare le diff pour voir si seule la ligne 2 a changÃ©
        diff_output=$(git diff --cached -U0 "$file" 2>/dev/null | tr -d '\r')

        # DÃ©tecter si c'est uniquement un passage vers "âœ… working" (dÃ©tection par mot-clÃ©, pas emoji)
        is_validation_only=false
        if echo "$diff_output" | grep -q "^+.*working"; then
            # Si on passe de "to test" vers "working"
            if echo "$diff_output" | grep -q "^-.*to test"; then
                # VÃ©rifier qu'il n'y a pas d'autres modifications significatives
                # On exclut les lignes de diff (--- et +++), les marqueurs de contexte (@@), et les lignes de statut
                other_changes=$(echo "$diff_output" | grep -E "^[+-]" | grep -v "^---" | grep -v "^+++" | grep -v "^@@" | grep -v "^-.*to test" | grep -v "^+.*working" | wc -l)
                if [ "$other_changes" -eq 0 ]; then
                    is_validation_only=true
                fi
            fi
        fi

        if [ "$is_validation_only" = true ]; then
            # Validation uniquement â†’ pas de bump de version
            validated_files+=("$file: âœ… validÃ© (v$current_version)")
            echo "âœ“ Blueprint validÃ© (sans bump) : $file"
            continue
        fi

        # Modification normale â†’ bump version + statut "to test"
        major=$(echo "$current_version" | cut -d. -f1)
        minor=$(echo "$current_version" | cut -d. -f2)
        patch=$(echo "$current_version" | cut -d. -f3)
        patch=$((patch + 1))
        new_version="$major.$minor.$patch"

        # CrÃ©er un fichier temporaire pour les modifications
        temp_file="${file}.tmp"

        # Traiter le fichier
        awk -v new_ver="$new_version" -v commit_msg="$commit_msg" '
            # Ligne 1 : Version
            NR == 1 && /^# Version:/ {
                print "# Version: " new_ver
                next
            }
            # Ligne 2 : Statut (remplacer par "to test" avec message de commit)
            NR == 2 && /^#.*to test|^#.*working/ {
                print "# ðŸ§ª to test : " commit_msg
                next
            }
            # Ligne 2 : Si pas de statut existant, l insÃ©rer avant la ligne actuelle
            NR == 2 && !/^#.*to test/ && !/^#.*working/ {
                print "# ðŸ§ª to test : " commit_msg
                print
                next
            }
            # Remplacer Version: dans la description
            in_desc && /^[[:space:]]+Version:/ {
                sub(/Version:[[:space:]]*[0-9]+\.[0-9]+\.[0-9]+/, "Version: " new_ver)
                print
                in_desc = 0
                next
            }
            # DÃ©tecter le dÃ©but de description
            /description:[[:space:]]*>/ {
                in_desc = 1
            }
            # Imprimer toutes les autres lignes
            { print }
        ' "$file" > "$temp_file"

        # Remplacer le fichier original
        mv "$temp_file" "$file"

        # Ajouter le fichier modifiÃ© au commit
        git add "$file"

        modified_files+=("$file: $current_version â†’ $new_version")
        echo "âœ“ Version mise Ã  jour : $file"
    fi
done < <(git diff --cached --name-only -z --diff-filter=ACM)

# ==============================================================================
# GÃ‰NÃ‰RATION DU FICHIER STATUS.MD
# ==============================================================================
generate_status() {
    echo "# Statut des Blueprints" > "$STATUS_FILE"
    echo "" >> "$STATUS_FILE"
    echo "_GÃ©nÃ©rÃ© automatiquement par pre-commit_" >> "$STATUS_FILE"
    echo "" >> "$STATUS_FILE"

    # Parcourir tous les fichiers yaml du dossier blueprints (triÃ©s alphabÃ©tiquement)
    for yaml_file in $(ls "$BLUEPRINTS_DIR"/*.yaml 2>/dev/null | sort); do
        if [ -f "$yaml_file" ]; then
            filename=$(basename "$yaml_file")
            line2=$(sed -n '2p' "$yaml_file" | tr -d '\r')

            # Extraire l'icÃ´ne et le commentaire (dÃ©tection par mots-clÃ©s, pas emojis)
            if echo "$line2" | grep -q "working"; then
                icon="âœ…"
                # Extraire le commentaire aprÃ¨s "working" (avec ou sans :)
                comment=$(echo "$line2" | sed -E 's/^#[^:]*:\s*//')
            elif echo "$line2" | grep -q "to test"; then
                icon="ðŸ§ª"
                # Extraire le commentaire aprÃ¨s "to test :"
                comment=$(echo "$line2" | sed -E 's/^#[^:]*:\s*//')
            else
                icon="â“"
                comment=""
            fi

            # Ã‰crire la ligne dans status.md avec backticks autour du filename
            if [ -n "$comment" ]; then
                echo "$icon \`$filename\` : $comment" >> "$STATUS_FILE"
            else
                echo "$icon \`$filename\`" >> "$STATUS_FILE"
            fi
        fi
    done

    # Ajouter status.md au commit
    git add "$STATUS_FILE"
    echo ""
    echo "ðŸ“‹ status.md rÃ©gÃ©nÃ©rÃ©"
}

# ==============================================================================
# GÃ‰NÃ‰RATION DU FICHIER LINKS.MD
# ==============================================================================
generate_links() {
    LINKS_FILE="blueprints/links.md"
    BASE_URL="https://raw.githubusercontent.com/DavidBabel/ha/master/blueprints/automation/DavidBabel/"

    # Vider le fichier de sortie
    > "$LINKS_FILE"

    # Tableau associatif pour stocker les liens par catÃ©gorie
    declare -A categories

    # Parcourir tous les fichiers .yaml
    for yaml_file in "$BLUEPRINTS_DIR"/*.yaml; do
        if [ -f "$yaml_file" ]; then
            filename=$(basename "$yaml_file")

            # Lire la troisiÃ¨me ligne pour extraire la catÃ©gorie
            category=$(sed -n '3p' "$yaml_file" | tr -d '\r' | grep -o "# Appartement:.*" | sed 's/# Appartement: *//')

            # Si pas de catÃ©gorie trouvÃ©e, mettre "Autre"
            if [ -z "$category" ]; then
                category="Autre"
            fi

            # Ajouter le lien Ã  la catÃ©gorie
            if [ -z "${categories[$category]}" ]; then
                categories[$category]="${BASE_URL}${filename}"
            else
                categories[$category]="${categories[$category]}"$'\n'"${BASE_URL}${filename}"
            fi
        fi
    done

    # Trier les catÃ©gories et Ã©crire dans le fichier (safe si espaces)
    while IFS= read -r category; do
        [ -z "$category" ] && continue
        echo "# Appartement: $category" >> "$LINKS_FILE"
        echo "${categories[$category]}" >> "$LINKS_FILE"
        echo "" >> "$LINKS_FILE"
    done < <(printf '%s\n' "${!categories[@]}" | sort)

    # Ajouter links.md au commit
    git add "$LINKS_FILE"
    echo "ðŸ“‹ links.md rÃ©gÃ©nÃ©rÃ©"
}

# GÃ©nÃ©rer les fichiers
generate_status
generate_links

# RÃ©sumÃ©
if [ ${#validated_files[@]} -gt 0 ]; then
    echo ""
    echo "âœ… Blueprints validÃ©s (sans bump de version) :"
    for msg in "${validated_files[@]}"; do
        echo "  â€¢ $msg"
    done
fi

if [ ${#modified_files[@]} -gt 0 ]; then
    echo ""
    echo "ðŸ“¦ Versions incrÃ©mentÃ©es + statut 'ðŸ§ª to test' :"
    for msg in "${modified_files[@]}"; do
        echo "  â€¢ $msg"
    done
fi

exit 0

